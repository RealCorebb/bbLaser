"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Path = void 0;
const Shape_1 = require("./Shape");
const Line_1 = require("./Line");
const Wait_1 = require("./Wait");
const CubicCurve_1 = require("./CubicCurve");
const svg_pathdata_1 = require("svg-pathdata");
const QuadCurve_1 = require("./QuadCurve");
const helpers_1 = require("./helpers");
const constants_1 = require("./constants");
const arcToBezier = require("svg-arc-to-cubic-bezier");
class Path extends Shape_1.Shape {
    constructor(options) {
        super();
        this.transformSize = (command) => {
            // TODO: yes this is a bit messy.
            if ('x' in command) {
                command.x = this.x + command.x / this.width;
            }
            if ('x1' in command) {
                command.x1 = this.x + command.x1 / this.width;
            }
            if ('x2' in command) {
                command.x2 = this.x + command.x2 / this.width;
            }
            if ('y' in command) {
                command.y = this.y + command.y / this.height;
            }
            if ('y1' in command) {
                command.y1 = this.y + command.y1 / this.height;
            }
            if ('y2' in command) {
                command.y2 = this.y + command.y2 / this.height;
            }
            if ('rX' in command) {
                command.rX = this.x + command.rX / this.width;
            }
            if ('rY' in command) {
                command.rY = this.y + command.rY / this.height;
            }
            return command;
        };
        this.x = options.x || 0;
        this.y = options.y || 0;
        this.width = options.width || 1;
        this.height = options.height || 1;
        this.color = options.color;
        this.path = options.path;
        this.waitAmount = options.waitAmount || constants_1.MAX_WAIT_AMOUNT;
        this.blankingAmount = options.blankingAmount || constants_1.BLANKING_AMOUNT;
    }
    draw(resolution) {
        const pathData = new svg_pathdata_1.SVGPathData(this.path)
            // Transforms relative commands to absolute so we don't have to implement relative commands at all!
            .toAbs()
            // Transforms S and T commands to C and Q so we don't have to implement S and T commands!
            .normalizeST()
            .transform(this.transformSize);
        if (!pathData.commands.length) {
            return [];
        }
        // The path can end by going to back to the first drawn line
        let lastMoveCommand;
        // Keep track of where the last line was drawn so relative positions work
        let prevX = 0;
        let prevY = 0;
        const points = pathData.commands.reduce((accumulator, command) => {
            let commandPoints = [];
            switch (command.type) {
                case svg_pathdata_1.SVGPathData.MOVE_TO:
                    commandPoints = new Wait_1.Wait({
                        x: command.x,
                        y: command.y,
                        amount: this.blankingAmount,
                    }).draw();
                    lastMoveCommand = command;
                    prevX = command.x;
                    prevY = command.y;
                    break;
                case svg_pathdata_1.SVGPathData.HORIZ_LINE_TO:
                case svg_pathdata_1.SVGPathData.VERT_LINE_TO:
                case svg_pathdata_1.SVGPathData.LINE_TO:
                    const toX = 'x' in command ? command.x : prevX;
                    const toY = 'y' in command ? command.y : prevY;
                    commandPoints = new Line_1.Line({
                        from: { x: prevX, y: prevY },
                        to: { x: toX, y: toY },
                        color: this.color,
                        waitAmount: this.waitAmount,
                        blankingAmount: this.blankingAmount,
                    }).draw(resolution);
                    prevX = toX;
                    prevY = toY;
                    break;
                case svg_pathdata_1.SVGPathData.CURVE_TO:
                    commandPoints = new CubicCurve_1.CubicCurve({
                        from: {
                            x: prevX,
                            y: prevY,
                            control: { x: command.x1, y: command.y1 },
                        },
                        to: {
                            x: command.x,
                            y: command.y,
                            control: { x: command.x2, y: command.y2 },
                        },
                        color: this.color,
                    }).draw(resolution);
                    prevX = command.x;
                    prevY = command.y;
                    break;
                case svg_pathdata_1.SVGPathData.QUAD_TO:
                    commandPoints = new QuadCurve_1.QuadCurve({
                        from: { x: prevX, y: prevY },
                        to: { x: command.x, y: command.y },
                        control: { x: command.x1, y: command.y1 },
                        color: this.color,
                    }).draw(resolution);
                    prevX = command.x;
                    prevY = command.y;
                    break;
                case svg_pathdata_1.SVGPathData.ARC:
                    // TODO: Of course it would be better to implement this properly instead of converting arcs to a cubic bezier.
                    const curves = arcToBezier({
                        px: prevX,
                        py: prevY,
                        cx: command.x,
                        cy: command.y,
                        rx: command.rX,
                        ry: command.rY,
                        xAxisRotation: command.xRot,
                        largeArcFlag: command.lArcFlag,
                        sweepFlag: command.sweepFlag,
                    });
                    let curvePrevX = prevX;
                    let curvePrevY = prevY;
                    curves.forEach((curve) => {
                        const curvePoints = new CubicCurve_1.CubicCurve({
                            from: {
                                x: curvePrevX,
                                y: curvePrevY,
                                control: { x: curve.x1, y: curve.y1 },
                            },
                            to: {
                                x: curve.x,
                                y: curve.y,
                                control: { x: curve.x2, y: curve.y2 },
                            },
                            color: this.color,
                        }).draw(resolution);
                        curvePrevX = curve.x;
                        curvePrevY = curve.y;
                        Array.prototype.push.apply(commandPoints, curvePoints);
                    });
                    prevX = command.x;
                    prevY = command.y;
                    break;
                case svg_pathdata_1.SVGPathData.CLOSE_PATH:
                    if (!lastMoveCommand) {
                        throw new Error('Path parsing error: close path command called without a prior move command.');
                    }
                    commandPoints = new Line_1.Line({
                        from: { x: prevX, y: prevY },
                        to: { x: lastMoveCommand.x, y: lastMoveCommand.y },
                        color: this.color,
                        blankAfter: true,
                        waitAmount: this.waitAmount,
                        blankingAmount: this.blankingAmount,
                    }).draw(resolution);
                    prevX = lastMoveCommand.x;
                    prevY = lastMoveCommand.y;
                    break;
                default:
                    console.warn(`Path parsing warning: command ${command.type} is not supported`);
            }
            let wait = [];
            if (accumulator.length >= 2 && commandPoints.length) {
                const nextPoint = commandPoints[0];
                const lastPoint = accumulator[accumulator.length - 1];
                const secondLastPoint = accumulator[accumulator.length - 2];
                // Get previous angle in radians.
                const previousAngle = Math.atan2(secondLastPoint.y - lastPoint.y, secondLastPoint.x - lastPoint.x);
                // Get next angle in radians.
                const nextAngle = Math.atan2(lastPoint.y - nextPoint.y, lastPoint.x - nextPoint.x);
                // Get difference in angle where 90 degrees is 0.5, and 180 is 1.
                const relativeAngle = Math.abs(Math.atan2(Math.sin(previousAngle - nextAngle), Math.cos(previousAngle - nextAngle))) / Math.PI;
                const waitShape = new Wait_1.Wait({
                    x: lastPoint.x,
                    y: lastPoint.y,
                    color: [lastPoint.r, lastPoint.g, lastPoint.b],
                    amount: Math.floor(this.waitAmount * relativeAngle),
                });
                wait = waitShape.draw();
            }
            return [...accumulator, ...wait, ...commandPoints];
        }, []);
        return (0, helpers_1.flatten)(points);
    }
}
exports.Path = Path;
